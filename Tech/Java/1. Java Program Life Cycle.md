# Java Program Lifecycle

---

## Short Notes

---

## 1. Source Code to Execution

.java → javac → .class (bytecode) → JVM → Native Machine Code

- Java source code is written in `.java`
- `javac` compiles source code into **platform-independent bytecode**
- Bytecode is executed by a **platform-dependent JVM**

---

## 2. JDK vs JRE vs JVM

**JDK (Java Development Kit)**  
- Contains `javac`, `javadoc`, `jar`, debugger
- Includes JRE
- Used for development

**JRE (Java Runtime Environment)**  
- Contains JVM and core libraries
- Used only for running applications

**JVM (Java Virtual Machine)**  
- Loads, verifies, optimizes, and executes bytecode

---

## 3. JVM Class Lifecycle

Loading  
↓  
Linking  
- Verification  
- Preparation (static variables default initialization)  
- Resolution  
↓  
Initialization (static blocks execution)  
↓  
Usage  
↓  
Unloading

---

## 4. ClassLoader Hierarchy

Bootstrap ClassLoader  
↑  
Platform (Extension) ClassLoader  
↑  
Application ClassLoader  

- Follows **Parent Delegation Model**
- Prevents overriding of core Java classes

---

## 5. Execution Model

### Interpretation
- Bytecode executed line-by-line
- Faster startup, slower execution

### JIT Compilation
- JVM detects **hot methods**
- Compiles them into native machine code
- Optimized code reused for subsequent calls

### Tiered Compilation
- Interpreter: immediate execution
- C1 Compiler: fast, light optimizations
- C2 Compiler: aggressive optimizations

---

## 6. JVM Runtime Memory Areas

Heap  
- Young Generation  
- Old Generation  

Metaspace (class metadata)

Thread Stack  
PC Register  
Native Method Stack  

- Heap stores objects
- Stack stores method calls
- Garbage Collector manages heap memory

---

## 7. Garbage Collection

- Automatic memory management
- Based on **generational hypothesis**
- Modern collectors:
  - G1
  - ZGC
  - Shenandoah
- Goal: balance throughput and pause time

---

## 8. Java Memory Model (JMM)

Defines:
- Visibility
- Ordering
- Atomicity

Key concepts:
- volatile
- synchronized
- happens-before relationship

---

## 9. Platform Independence (WORA)

- Bytecode is platform-independent
- JVM is platform-dependent
- Same `.class` file runs anywhere with a compatible JVM

---

## 10. Build and Packaging

Build tools:
- Maven
- Gradle

Packaging formats:
- JAR
- WAR
- EAR
- Fat / Uber JAR (Spring Boot)

---

## 11. Security Model

- Bytecode verification
- ClassLoader isolation
- Code signing and cryptography
- Security Manager (deprecated in Java 17+)

---

---

# Detailed Explanation

---

## Overview and Stages

The Java program lifecycle is a multi-stage process that transforms human-readable source code into executable instructions. It is designed to ensure platform independence, security, and performance.

Stages:
1. Editing – writing `.java` source code
2. Compilation – converting source code to bytecode
3. Execution – JVM runs bytecode as native instructions

This enables **Write Once, Run Anywhere (WORA)**.

---

## Role of JDK

The Java Development Kit provides everything required to develop and run Java applications.

Includes:
- Compiler (javac)
- Java Runtime Environment
- Development tools like javadoc and jar

The JDK is platform-dependent, but it produces platform-independent bytecode.

---

## Role of JRE

The Java Runtime Environment is required to run Java programs.

Includes:
- JVM
- Core Java libraries
- Supporting runtime files

It does not include development tools.

---

## Role of JVM

The Java Virtual Machine:
- Loads and verifies bytecode
- Interprets or JIT-compiles bytecode
- Manages memory using garbage collection
- Enforces security

Each operating system has its own JVM implementation, all following the same specification.

---

## Java Compilation to Bytecode

Compilation steps:
1. Developer writes `.java` file
2. `javac` converts it into `.class` file
3. Each class produces a separate bytecode file

Bytecode is an intermediate, platform-independent representation.

---

## Bytecode Structure

A `.class` file contains:
- Magic number: 0xCAFEBABE
- Version information
- Constant pool
- Field and method definitions
- Bytecode instructions

---

## Platform Independence

Java achieves platform independence using:
- Platform-independent bytecode
- Platform-specific JVM implementations

As long as a compatible JVM exists, the same bytecode can run without recompilation.

---

## Java Execution Model

### Interpretation
- Executes bytecode instruction-by-instruction
- Slower but enables quick startup

### Just-In-Time Compilation
- JVM profiles execution
- Frequently executed code is compiled to native machine code
- JVM may de-optimize and recompile if assumptions change

### Tiered Compilation
- Interpreter → C1 → C2
- Balances startup speed and peak performance

---

## Class Loading and Verification

ClassLoader hierarchy:
- Bootstrap
- Platform
- Application

Uses parent delegation to ensure security.

Bytecode verification ensures:
- Structural correctness
- Type safety
- Secure memory access

---

## Runtime Services

### Garbage Collection
- Automatically reclaims unused objects
- Uses generational memory model
- Modern low-latency collectors supported

### Memory Areas
- Heap
- Metaspace
- Stack
- PC Register
- Native Method Stack

Supports multithreading and synchronization.

---

## Build Process

Typical workflow:
1. Write code in `src/main/java`
2. Compile into `.class` files
3. Package into JAR or WAR
4. Execute using JVM

Build tools integrate easily with CI/CD pipelines.

---

## Security and Sandboxing

Java security relies on:
- Bytecode verification
- ClassLoader isolation
- Code signing and cryptography
- Security Manager (deprecated, Java 17+)

---

